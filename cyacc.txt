=========================  calc.c


#include "calc.h"
#include <stdlib.h>
#include <string.h>
#include "utils.h"
#include "func.h"
#include "gramm.h"
#include <stdio.h>

// User defined data types 
struct list *cmpnd_types;

// Aliases info.
struct list *aliases;
struct list *global_sym_table;

struct btype_info
basic_types[] = {
  {"void", 0},
  {"char", 1},
  {"int", 4},
  {"float", 4},
  {"short", 2},
  {"long", 8}
};

void
init_tables () {
  aliases = NULL;
  cmpnd_types = NULL;
  func_table = NULL;
  global_sym_table = NULL;
  int i = 0;
  for (i = 0; i < 6; ++i) {
    basic_types[i].t.ttype = BASIC_TYPE;
    basic_types[i].t.val.btype = i;
    SET_NOT_ARRAY(basic_types[i].t);
  }
}

// incompl parameter to differentiate between 
// empty struct and fwd. declaration
struct struct_type 
*create_struct (char *name, struct memb_list* elems, int incompl) { 
  struct struct_type *ss = malloc(sizeof(struct struct_type));
  copy_name(&ss->name, name);
  // printf("Creating a struct with name %s\n", name);
  int size = 0;
  struct memb_list *node = elems;
  while (node) {
    size += size_of(node->type);
    node = node->next;
  }
  
  if (incompl) {
    ss->size = -1;
    ss->elems = NULL;
  }
  else {
    ss->size = size;
    ss->elems = elems;
  }

  // Create new node
  list_append_elem(&cmpnd_types, list_create_elem(ss));
  return ss;
}

struct memb_list *
create_member (char *name, struct type t, struct memb_list *join) {
  struct memb_list *this = malloc(sizeof(struct memb_list));
  copy_name(&this->name, name);
  this->type = t;
  this->next = join;
  return this;
}

struct struct_type 
*get_struct (char *name) {
  struct list *node = cmpnd_types;
  struct struct_type *s;
  while (node) {
    s = (struct struct_type *)node->data;
    if (!strcmp(s->name, name))
      return s;
    node = node->next;
  }
  // printf("Struct not found");
  // No match
  return NULL;
}

// Get element by offset
struct type 
struct_get_elem (struct struct_type *stype, int oft) {
  struct memb_list *node = stype->elems;
  int count = 0;
  while (node) {
    if (oft == count)
      return node->type;
    // printf("c: %d, ", count);
    count += size_of(node->type);
    node = node->next;
  }
  printf("\n");
  struct type t; t.ttype = UNDEF_TYPE;
  return t;
}
  

int 
struct_calc_offset (struct struct_type *stype, char *name) {
  struct memb_list *node = stype->elems;
  int offset = 0;
  while (node) {
    if (!strcmp(node->name, name))
      return offset;
    offset += size_of(node->type);
    node = node->next;
  }

  return -1;
}



void
delsym_scope(int depth) {
  struct list *node; symrec *ptr;
  for (node = global_sym_table; node; node = node->next) {
    ptr = (symrec *)node->data;
    if (!ptr->scope.over && ptr->scope.level == depth)
      ptr->scope.over = true;
  }
  return;
}

struct type *
get_alias (char *name) {
  struct list *node = aliases;
  struct alias_rec *alias;
  while (node) {
    alias = (struct alias_rec*)node->data;
    if (!strcmp(alias->name, name)) 
      return &alias->to;
    node = node->next;
  }

  // Alias not found
  return NULL;
}

static struct list *
create_alias_entry(char *name, struct type tar) {
  struct alias_rec *alias = malloc(sizeof(struct alias_rec));
  copy_name(&alias->name, name);
  alias->to = tar;
  struct list *node = malloc(sizeof(struct list));
  node->next = NULL;
  node->data = (void *)alias;
  return node;
}

void
create_alias (char *name, struct type t) {
  // Check if identifier 
  // is in the symbol table              
  struct list *node = aliases, *last = aliases;
  struct alias_rec *alias;
  while (node) {
    last = node;
    node = node->next;
  }

  node = create_alias_entry(name, t);
  if (aliases)
    last->next = node;
  else 
    aliases = node;

  return;
}

/* Get the size of type t, including 
 * array dimensions etc. */
int 
size_of (struct type t) {
  return t.array.size * base_size_of(t);
  // if (t.array.size >= 0)
  //   return size * t.array.size;
  // else return -1;
} 

/* Get the size of target pointed to */
int size_of_target (struct type t) {
  if (is_array(t))
    return (t.array.size/t.array.dimen[0] * base_size_of(t));
  if (is_pointer(t))
    return size_of(*(t.val.ptr_to));
  return size_of(t);
}

/* Size of type without array etc. */
int
base_size_of (struct type t) {
  int size;
  if (t.ttype == BASIC_TYPE)  {
    size = basic_types[t.val.btype].size;
  }
  else if (t.ttype == PTR_TYPE) {
    size = SIZEOFPTR;
  }
  else if (t.ttype == COMPOUND_TYPE) {
    // Struct or union
    size = (t.val.stype)->size;
  }
  return size;
}


=========================  calc.h


#include <stdbool.h>
// #include "list.h"

#define _CALC

#define NOT_DEREF 0
#define INDEX_EXPR 2
#define DEREF_EXPR 1

#define SET_NOT_DEREF(x) (x).deref.type = NOT_DEREF; (x).deref.idx = NULL; (x).deref.mem_oft = -1;
#define is_mem_ref(x) ((x).deref.type == INDEX_EXPR && (x).deref.mem_oft >= 0)
#define is_indexed(x) ((x).deref.type == INDEX_EXPR)
#define is_derefd(x) ((x).deref.type == DEREF_EXPR)

#define is_compound(x) ((x).ttype == COMPOUND_TYPE && !is_array(x))
#define is_vector(x) (is_array(x) || is_pointer(x))
#define is_array(x) ((x).array.n > 0)
#define is_pointer(x) ((x).ttype == PTR_TYPE)

#define is_int_type(t) ((t).ttype == BASIC_TYPE && ((t).val.btype == INT_TYPE || (t).val.btype == CHAR_TYPE) && !is_array(t))
#define is_void_type(t) ((t).ttype == BASIC_TYPE && (t).val.btype == VOID_TYPE)
#define is_int_expr(e) (is_int_type(e.type))

#define is_plus(op) (op == '+' || op == '-')
#define is_relational(op) (op == '>' || op == '<' || op == LE_OP || op == GE_OP || op == EQ_OP)
#define is_logical(op) (op == AND_OP || op == OR_OP)
#define is_binary(op) (op == '&' || op == '|' || op == '^')

struct scope_type {
  int level;
  int label;
  int over; // is the scope of this var over
};

struct struct_type;

// `struct type` is passed around by value,
// not pointers.
/* An alternate way to do this, and probably the way gcc does it,
 * is to store pointers to more type structs even in case of 
 * arrays, and in that case every of these structs will have 
 * at max a 1-D array, which will be an array of pointers
 * to further array type. So, in int *a[5][6][7]; we store one 
 * type struct with a array 5 of pointers to int [6][7], i.e the
 * first struct element corresponds to 5 int * (*)[6][7] pointers, the 
 * second to 6 int * (*)[7] pointers(i.e pointers to [7] array of
 * int *, and the third to int * (*) or pointer to int *, and so on.
 */ 

/* Also, arrays usually decay to pointers to their
  first element type */
/* TODO: Change the list implementation from "list.c"
 * to suit the usage here, and use that everywhere */
struct array_type{
    int n;
    int size;
    int *dimen;
}; 


struct type {
  // Indicates basic types
  int ttype;
  union {
    int btype;
    struct struct_type *stype;
    /* THis has to be changed to the standard list */
    struct type *ptr_to;
  } val;
  struct array_type array;
};


struct btype_info{
  char *name;
  int size;
  struct type t;
};

/* Data type for links in the chain of symbols.      */
struct symrec
{
  char *name;  /* name of symbol                     */
  struct type type;
  bool param;
  struct scope_type scope;
};

typedef struct symrec symrec;

struct alias_rec {
  char *name;
  struct type to;
};

struct memb_list {
  char *name;
  struct type type;
  struct memb_list *next;
};

/* type of compound type mem here
i.e STRUCT vs. UNION vs. enum and so on */
struct struct_type {
  char *name;
  int size;
  struct memb_list *elems;
} ;

struct pair {
  int patch;
  int label;
};

struct loop_type {
  struct pair this;
  struct pair prev;
};

union expr_val {
  char *const_str;
  int quad_no;
  symrec *sym;
};

struct deref_info {
  int type;
  struct expr_type *idx; /* Stores expression for the index of [idx] */
  int mem_oft; /* Stores member offset for struct member access */
};

struct expr_type {
  int ptr;
  union expr_val val;
  struct type type;
  /* Stores info of dereference for 
   * indexing and ptr deref expr */
  struct deref_info deref; 
};


struct quad {
  int line;
};


/* The symbol table: a chain of `struct symrec'.     */
/* TODO: Change Symtable to struct list * */
extern struct list *global_sym_table;
// Alias table, list of `struct alias_rec'
extern struct list *aliases;
// Struct and Unions table, list of `struct struct_type'
extern struct list *cmpnd_types;
extern struct btype_info basic_types[];


void delsym_scope(int depth);

struct struct_type *create_struct(char *name, struct memb_list* elems, int incompl);
struct struct_type *get_struct(char *name);
struct type struct_get_elem (struct struct_type *stype, int oft);
int struct_calc_offset (struct struct_type *stype, char *name);
void init_tables();

struct type *get_alias(char *name);
void create_alias(char *name, struct type type);

struct memb_list *create_member (char *name, struct type t, struct memb_list *join);

int size_of_target(struct type t);

int size_of (struct type t);
int base_size_of (struct type t);


=========================  func.c


#include "calc.h"
#include "utils.h"
#include "func.h"
#include <stdlib.h>
#include <string.h>
#include <stdio.h>

struct list *func_table;


void print_sym_table(struct list *sym_table) {
	struct list *node = sym_table;
	symrec * rec;
	printf("Symbol Tabl\n");
	while (node) {
		rec = (symrec *)node->data;
		printf("%s %d\n", rec->name, (rec->scope).level);
		node = node->next;
	}
}

struct func_rec *create_func(char *func_name, 
				struct type func_type)
{
	struct func_rec* ptr;
	ptr = (struct func_rec *) malloc(sizeof(struct func_rec));
	ptr->name = (char *) malloc(strlen(func_name) + 1);
	strcpy(ptr->name, func_name);

	ptr->ret_type = func_type;
	ptr->param_list = NULL;
	ptr->sym_table = NULL;
	ptr->num_param = 0;
	
	list_append_elem(&func_table, list_create_elem(ptr));
	return ptr;
}

struct func_rec *search_func(char *func_name)
{
	struct list *node = func_table;
	struct func_rec *func;
	while (node) {
		func = (struct func_rec *)node->data;
		if (!strcmp(func_name, func->name))
			return func;
    node = node->next;
	}
	return NULL;
}

void 
create_param (struct func_rec *f, symrec *sym)
{
	if (!f)
		return;
	(f->num_param)++;
	list_append_elem(&f->param_list, list_create_elem(sym));
	return;
}

symrec *
putsym (struct func_rec *active_func, char *sym_name, 
    struct type sym_type, struct scope_type scope)
{
	// printf("in putsym");
  	// printf("%d\n", active_func);

  struct list *sym_table;
 

  symrec *ptr;
  ptr = (symrec *) malloc (sizeof (symrec));
  copy_name(&ptr->name, sym_name);
  ptr->type = sym_type;
  // ptr->value.var = 0; /* set value to 0 even if fctn.  */
  scope.over = 0;
  ptr->scope = scope;

  if (active_func) {
  	list_append_elem(&(active_func->sym_table), list_create_elem(((void *)ptr)));
  }
  else
  	list_append_elem(&(global_sym_table), list_create_elem(((void *)ptr)));

 	// print_sym_table(global_sym_table);

    // sym_table = global_sym_table;
  return ptr;
}

symrec *
getsym (struct func_rec *active_func, 
    char *sym_name, struct scope_type scope)
{
  struct list *sym_table;
  struct list* node;
  symrec *ptr, *ret = NULL;
  if (active_func) {
    sym_table = active_func->sym_table;
    int larg = -1;
    for (node = sym_table; node; node = node->next) {
      ptr = (symrec *)node->data;
        // Check scoping rules too
      // printf("Name: %s, %d\n", ptr->name, scope.level);
      if (!ptr->scope.over && ptr->scope.level <= scope.level
          && scope.level > larg && !strcmp (ptr->name,sym_name)) {
        ret = ptr;
        larg = ptr->scope.level;
      }
    }
  }  
  if (ret)
    return ret;

  // printf("NAme,%s\n", sym_name);
  sym_table = global_sym_table;
  for (node = sym_table; node; node = node->next) {
    // printf("In the thing=========================\n");
    ptr = (symrec *)node->data;
      // Check scoping rules too
    // printf("%s, %s\n", ptr->name, sym_name);

    if (!strcmp (ptr->name, sym_name))
      return ptr;
  }

// ?("ret NULL");
  
  return NULL;

}



// void search_var(node* list, int found, int level
// 	const char* var_name)
// {
// 	node* ptr;
// 	found = 0;
// 	for(ptr = list; ptr != NULL && ptr->level == level;
// 		ptr = ptr->next)
// 	{
// 		if(strcmp(ptr->rec->name, var_name) == 0)
// 		{
// 			found = 1;
// 			break;
// 		}	
// 	}

// }

// void delete_var(struct func_rec* namptr, int level)
// {
// 	node* ptr, temp_ptr;
// 	for(ptr = namptr->var_list; ptr!= NULL && 
// 		ptr->level == level;)
// 	{
// 		remov_sym(node->rec);
// 		ptr =  ptr-> next;
// 		free(namptr->var_list);
// 		namptr->var_list = ptr;
// 	}

// }



=========================  func.h


#ifndef _CALC
#include "calc.h"
#endif

#ifndef _UTILS
#include "utils.h"
#endif


extern struct list *func_table;

struct func_rec {
	int defined;
	int label;
	char *name; // name of the symbol
	struct type ret_type; // result type of the function
	struct list *param_list; // list containing the parameters
	struct list *sym_table;
	int num_param;
};

struct func_rec *create_func(char *func_name, 
				struct type func_type);
struct func_rec *search_func(char *func_name);
void create_param (struct func_rec *f, symrec *sym);

symrec *putsym (struct func_rec *active_func, char *sym_name, 
    struct type sym_type, struct scope_type scope);
symrec *getsym (struct func_rec *active_func, 
    char *sym_name, struct scope_type scope);

void print_sym_table(struct list *sym_table);


=========================  gramm.h


#include <stdio.h>

/* Basic types */
#define VOID_TYPE 0
#define CHAR_TYPE 1
#define INT_TYPE 2
#define FLOAT_TYPE 3
#define SHORT_TYPE 4
#define LONG_TYPE 5


#define QUAD_PTR 0
#define SYM_PTR 2
#define CONST_PTR 1
#define MAX_NEST_DEPTH 256
#define MAX_ARRAY_DIMEN 256

#define JUMP_LABEL_NUMBER 0
#define JUMP_LABEL_NAME 1
#define JUMP_PATCH 2

#define UNDEF_TYPE -1
#define INCOMPL_TYPE 0
#define COMPOUND_TYPE 2
#define BASIC_TYPE 1
#define PTR_TYPE 3

#define STRUCT_TAG 11
#define UNION_TAG 12

#define MAX_INT_SIZE 30
#define MAX_IDENTIFIER_SIZE 30
// #define CHAR 1
// #define INT 2
// #define FLOAT 3

#define SIZEOFPTR 4


#define SET_NOT_ARRAY(x) (x).array.n = 0; (x).array.dimen = NULL; (x).array.size = 1

extern int nlabel;
extern int depth;
extern FILE *yyin;

int lineno;
int colno;

void out_label();
int out_jmp(struct expr_type *e, void *label, int type);
void backpatch(int label, int patch);
void out_assign(char *name, struct expr_type expr);
void out_index (struct expr_type e);
struct expr_type parse_member_ref (struct expr_type e, char *mem);
void parse_expr (struct expr_type *result, struct expr_type e1,
          struct expr_type e2, int op);
void parse_unary_expr (struct expr_type *result, 
              struct expr_type e1, int op);
void out_deref (struct expr_type e);
void out_const_index (struct expr_type e, const int c);

void make_quad (struct expr_type e1, struct expr_type e2, int op);
void make_two_quad (struct expr_type e1, int op);

void out_gen_quad (struct expr_type e);

struct expr_type get_vector_elem (struct expr_type e);
struct expr_type cmpnd_idx (struct expr_type e, struct expr_type idx);
struct expr_type cmpnd_idx2 (struct expr_type e, struct expr_type idx);
struct expr_type parse_indexed_expr (struct expr_type e, struct expr_type idx);
struct expr_type parse_deref_expr (struct expr_type e, struct expr_type idx);

int sout_expr_with_deref (char *buf, struct expr_type e);
void out_assign_expr (struct expr_type lval, struct expr_type rval);
void parse_assignment (struct expr_type lval, struct expr_type rval);

void out_begin_func ();
void out_end_func ();
void out_return (struct expr_type *e);
void out_param (struct expr_type e);
void out_call (struct func_rec *f);

void error (char *msg);



=========================  gramm.y


// Todo: Add coercibility checks
// Add string literals

/* TODO: Store values for constants */
/* TODO: SET INDICES and #defines PROPERLY */

%{
#include "calc.h"  /* Contains definition of `symrec'        */
#include "utils.h"
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <stdbool.h>
#include "func.h"
#include "gramm.h"

#define DEFAULT_OUT "int.out"

int vtype;
FILE *outfile;

int next_quad;
int label_no;
int patches[MAX_NEST_DEPTH];
int patch_idx;

struct pair cur_loop;

struct bigop {
    int op;
    char str[3];
};

int BIGOPS_NUM;
struct list *nested;
struct scope_type scope;

struct func_rec *active_func;
FILE *yyin;

// Builtin type info.
void init_globals();

%}

%union {
  double  val;  /* For returning numbers.                   */  
  char *id_name;
  char *t_name;
  symrec *sym;
  struct sym_list{
    char *name;
    struct type type;
  } sym_npt; // stands for name and pointer types
  struct {
    int type;
    int val;
  } constant;
  struct expr_type e;
  struct type type;
  int patch;
  struct pair dual_patch;
  struct loop_type loop;
  int ttype;
  struct memb_list *tlist;
  struct list *l;
  struct type *alias_type;
}

%token OR_OP AND_OP EQ_OP NE_OP
%token LE_OP GE_OP LSHFT_OP RSHFT_OP INC_OP DEC_OP

%token TYPEDEF EXTERN STATIC AUTO REGISTER
%token CHAR SHORT INT LONG SIGNED UNSIGNED FLOAT DOUBLE CONST VOLATILE VOID
%token STRUCT UNION ENUM ELLIPSIS

%token CASE DEFAULT SWITCH WHILE DO FOR GOTO CONTINUE BREAK RETURN
%token SIZEOF


%token <e> CONSTANT        /* Simple double precision number   */
%token <id_name> IDENTIFIER/* Variable and Function            */
%token <alias_type> ALIAS_NAME

%type <id_name> func_name
%type <patch> if_clause
%type <dual_patch> else_clause 
%type <loop> while_clause
%type <e> expr primary_expr opt_init function_call eval_expr
%type <type> type_name compound_type
%type <l> var_dlist var_definition actual_params actual_params_list
%type <sym_npt> symbol_name
%type <ttype> type_type
%type <t_name> opt_ctype_name ctype_name;
%type <tlist> opt_member_decl_list member_decl_list member_decl memb_list
%type <e> indexing

// %precedence mult_op
// %precedence ad_op
%expect 1
%left ','
%right '='
%left OR_OP
%left AND_OP
%left '&' 
%left '^'
%left '|'
%left EQ_OP NE_OP
%left '<' '>' LE_OP GE_OP
%left LSHFT_OP RSHFT_OP
%left '-' '+'
%left '*' '/' '%'
%left DEREF
%right INC_OP DEC_OP 
%right ')'
%right '!' '~'
%left UMINUS     /* Negation--unary minus */
%left '.'
%left '['

%nonassoc IF
%nonassoc ELSE

/* Grammar follows */

%%


input :   /* empty */ { dump_tables(); }
      | global_statement input 
      ;

global_statement  :  declaration_statement {}
                  |  type_definition {}
                  |  function_definition {}
                  ;

body  :  body_statement body {}
      |  /* empty */
      ;

body_statement    : declaration_statement {}
                  | jump_statement {}
                  | expression_statement {}
                  | error { yyerrok; }
                  | selection_statement {}
                  | iterative_statement {}
                  | block_statement {}
                  | label_stmt {}
                  | return_statement {}
                  ;

// User defined label
label_stmt: IDENTIFIER ':' { fprintf(outfile, "%s:  ", $1); }
          ;

return_statement  : RETURN eval_expr ';' { out_return(&$2); }
                  | RETURN ';' { out_return(NULL); }
                  ;

/* TODO: prototypes */
/* ERROR HANDLING syntax vs. semantic errors */
function_definition  : func_head block_statement 
            {
              active_func = NULL;
              out_end_func();  
            }
            ;

func_head : res_id begin_params '(' param_decl_list ')' end_params
            {
              active_func->label = label_no;
              out_begin_func();
            }
          ;

begin_params : /* empty */ { scope.level++; scope.label = label_no; }
            ;
end_params : /* empty */ { scope.level--; }
            ;

res_id  : type_name IDENTIFIER
          {
            struct func_rec *func;
            if (func = search_func($2)) {
              if (func->defined)
                error("Redefinition of function");
              /* Check if the prot. is not consistent with head */
              active_func = func;
            }
            else {
              active_func = create_func($2, $1);
            }
          }
        ;

param_decl_list : param_list
                | /* empty */ { }
                ;

param_list  : param_decl
            | param_decl ',' param_list
            ;

param_decl  : type_name symbol_name
              {
                struct array_type arr;
                symrec *sym = getsym(active_func, $2.name, scope);
                if (sym && sym->scope.level == scope.level)
                  error("Redefinition of parameter");
                sym = putsym(active_func, $2.name, $1, scope);
                create_param(active_func, sym);

                if (sym->type.ttype == INCOMPL_TYPE) {
                  arr = $2.type.array;
                  if ($1.ttype == INCOMPL_TYPE)
                    error("incomplete type for varibale");
                  sym->type = $1;
                  sym->type.array = arr;
                }
                else if (sym->type.ttype == PTR_TYPE) {
                  struct type *t = sym->type.val.ptr_to;
                  // Travese the list of ptr types
                  while (t->ttype == PTR_TYPE)
                    t = t->val.ptr_to;
                  // Set the type of the last node to the basic
                  // or compound type that is type_name
                  if (t->ttype == INCOMPL_TYPE) {
                    arr = (*t).array;
                    *t = $1;
                    (*t).array = arr;
                  }
                }
                  // TODO: Relloc in the entire ptr_to linked list
                  // sym->type.array.dimen = realloc(sym->type.array.dimen, sym->type.array.n * sizeof(int));
              }
            ;

/* TODO: Differentiate between stmts inside 
and outside functions */
block_statement : begin_sub '{' body '}' end_sub
                ;

begin_sub :   /* eps */
              {
                scope.label = label_no;
                // Push scope info onto stack
                list_prepend_elem(&nested, 
                  list_create_elem((void *)label_no));
                scope.level++;
                out_label();
              }
          ;

end_sub   :   /* eps */
              {
                void *data = list_pop_front(&nested);
                scope.label = (int) data;
                // delsym_scope(scope.level);
                scope.level--;
              }
          ;

type_definition : aliasing ';'
                | compound_type ';'
                ;

// Forward declarations of structs ignored for now
/* TODO: Allow definitions of recursive structs pointers by 
 * combining the two */
/* TODO: Check for duplicate members */
compound_type   : type_type opt_ctype_name '{' member_decl_list '}'
                  { 
                    if (get_struct($2))
                      error("Redefinition of struct");
                    /* TODO: Differentiate b/w STRUCT and
                     * UNION */
                    $$.val.stype = create_struct($2, $4, false);
                    $$.ttype = COMPOUND_TYPE;
                    SET_NOT_ARRAY($$);
                    // If it is not null string
                    if ($2[0])
                      free($2);
                  }
                | type_type ctype_name
                  {

                    struct struct_type *s = get_struct($2);
                    if (!s)  {
                      // Forward declaration
                      $$.val.stype = create_struct($2, NULL, true);
                      $$.ttype = COMPOUND_TYPE;                      
                    }
                    else {
                      $$.ttype = COMPOUND_TYPE;
                      $$.val.stype = s;                    
                    }
                    SET_NOT_ARRAY($$);
                    free($2);
                  }
                ;

type_type : STRUCT { $$ = STRUCT_TAG; } 
          | UNION  { $$ = UNION_TAG; }
          ;

ctype_name  : IDENTIFIER 
              {
                copy_name(&$$, $1);
              }
            ;

opt_ctype_name: /* empty */ { $$ = ""; }
            | ctype_name  { $$ = $1; }
            ; 

/* TODO: Add case when the member list can 
also be empty */
member_decl_list:  member_decl opt_member_decl_list
              {
                // Join the two lists. 
                struct memb_list *mem = $1;
                while (mem->next)
                  mem = mem->next;
                mem->next = $2;
                $$ = $1;
              }

           ;

opt_member_decl_list: /* empty */ { $$ = NULL; }
                    | member_decl_list { $$ = $1; }
                    ;

member_decl : type_name memb_list ';'
              {
                struct memb_list *node = $2;
                /* TODO: Check for completeness of 
                  type here */
                if (is_void_type($1))
                  error("Structure has Void type member");

                // Backpatch
                while (node) {
                  struct type *t = &(node->type);

                  if (t->ttype != PTR_TYPE && 
                      is_incompl_type($1))
                    error("Structure Member has incomplete type");
                  // Travese the list of ptr types
                  while (t->ttype == PTR_TYPE)
                    t = t->val.ptr_to;
                  struct array_type arr = t->array;
                  *t = $1;
                  t->array = arr;

                  // TODO: Relloc in the entire ptr_to linked list
                  // sym->type.array.dimen = realloc(sym->type.array.dimen, sym->type.array.n * sizeof(int));
                  node = node->next;
                }
                $$ = $2;
              }
            ;

memb_list : symbol_name ',' memb_list 
            { 
              // Check for already defined members
              // symrec *rec = getsym(active_func, $1.name, scope);
              // if (rec && rec->scope.level == scope.level) {
              //   error("Redefinition of symbol");
              // }
              $$ = create_member($1.name, $1.type, $3);
              free($1.name);
            }
          | symbol_name
            {
              $$ = create_member($1.name, $1.type, NULL);
              free($1.name);
            }
        ;

aliasing  : TYPEDEF type_name IDENTIFIER
            { 
              struct type *t;
              if (t = get_alias($3))  {
                // Check type equivalence properly
                if (!is_equiv(*t, $2))
                  error("Conflicting types for typedef");
              }
              else 
                create_alias($3, $2);
            }
          ;


expression_statement  :  expr ';'
                      |  /*empty*/  ';'
                      ;


jump_statement  : CONTINUE ';'
                  { 
                    if (cur_loop.label == -1)
                      error("continue statement not within a loop");
                    out_jmp(NULL, &cur_loop.label, JUMP_LABEL_NUMBER); 
                  }
                | BREAK ';' 
                  { 
                    if (cur_loop.label == -1)
                      error("break statement not within a loop or a switch");
                    out_jmp(NULL, &cur_loop.patch, JUMP_PATCH); 
                  }
                | GOTO IDENTIFIER ';' { out_jmp(NULL, (void *)$2, JUMP_LABEL_NAME); } 
                ;

iterative_statement :  while_loop
                    // |  for_loop
                    // |  do_while_loop ';'
                    ;

while_loop          : while_clause body_statement
                      {
                        out_jmp(NULL, &($1.this.label), JUMP_LABEL_NUMBER);
                        int label = label_no;
                        out_label();
                        backpatch(label, $1.this.patch);
                        cur_loop = $1.prev;
                      }
                    ;

while_clause        : WHILE '(' expr ')'
                      {
                        $$.prev = cur_loop; 
                        $$.this.label = label_no;
                        out_label();
                        $$.this.patch = out_jmp(&$3, (void *)NULL, 0);
                        cur_loop = $$.this;
                      }
                    ;

selection_statement  :  if_clause body_statement {
                          int l_no = label_no;
                          out_label();
                          backpatch(l_no, $1); 
                        }
                     | if_clause body_statement else_clause body_statement
                       {
                          int l_no = label_no;
                          out_label();
                          backpatch($3.label, $1);
                          backpatch(l_no, $3.patch);
                       }
                     ;

if_clause   : IF '(' expr ')' {
                // returns patch number
                $$ = out_jmp(&$3, (void *)NULL, 0);
              }
            ;

else_clause   :  ELSE {
                    $$.patch = out_jmp(NULL, NULL, 0);
                    $$.label = label_no;
                    out_label();
                 }
              ;

declaration_statement : type_name var_dlist ';' 
                        {
                          struct list *node = $2;
                          struct symrec *sym;
                          /* TODO: Check for completeness of 
                            type here */

                          // Backpatch
                          while (node) {
                            sym = (symrec *) node->data;

                            if (sym->type.ttype != PTR_TYPE)
                              if (is_incompl_type($1))
                                error("Variable has incomplete type");
                              else if (is_void_type($1))
                                error("Void type varible declaration");

                            struct type *t = &(sym->type);
                            // Travese the list of ptr types
                            while (t->ttype == PTR_TYPE)
                              t = t->val.ptr_to;

                            struct array_type arr = t->array;
                            *t = $1;
                            t->array = arr;

                            // TODO: Relloc in the entire ptr_to linked list
                            // sym->type.array.dimen = realloc(sym->type.array.dimen, sym->type.array.n * sizeof(int));
                            node = node->next;
                          }
                        }
                      ;
          
var_dlist : var_definition ',' var_dlist { list_prepend_elem(&$3, $1); $$ = $3; }
          | var_definition { $$ = $1; }
          ;


var_definition  : symbol_name opt_init 
                  {
                    symrec *rec = getsym(active_func, $1.name, scope);
                    if (rec && rec->scope.level == scope.level) {
                      error("Redefinition of symbol");
                    }

                    print_type($1.type);
                    rec = putsym(active_func, $1.name, $1.type, scope);

                    $$ = list_create_elem(rec);  
                    // Assign result of expr to vaiable
                    // This is should be delayed to after the 
                    // type backpatch to check coercibility
                    if ($2.type.ttype != UNDEF_TYPE) {
                        out_assign($1.name, $2);
                    }
                    free($1.name);
                  }
                ;

// TAKE CARE OF PASSING BOTH NAME and 
// TYPE UP the TREE
symbol_name : IDENTIFIER 
              {
                copy_name(&$$.name, $1);
                // Create a new symbol table record
                // and assign it the thing from the old record  
                $$.type.ttype = INCOMPL_TYPE; 
                SET_NOT_ARRAY($$.type);
              }              
            /* TODO: Size decided by initializers */
            | symbol_name '[' CONSTANT ']'
              {
                struct sym_list db = $1;
                struct type *t = &($1.type);
                if (const_type($3.val.const_str) != INT_TYPE)
                  error("size of array has non-integer type");
                int size = const_val($3.val.const_str);
                if (!is_array(*t)) {
                  t->array.dimen = malloc(MAX_ARRAY_DIMEN * sizeof(int));
                  t->array.n = 1;
                }
                else {
                  t->array.n++;
                }
                if (t->array.n == MAX_ARRAY_DIMEN)
                  error("Can't have more than 256 dimension array");
                t->array.dimen[t->array.n - 1] = size;
                t->array.size *= size;
                $$ = $1;
              }
            | '*' symbol_name
              {
                struct sym_list db = $2;
                struct type *to = malloc(sizeof(struct type));
                *to = $2.type; // TYPE COPYING
                $$.type.ttype = PTR_TYPE;
                $$.type.val.ptr_to = to;
                SET_NOT_ARRAY($$.type);
                $$.name = $2.name;
              }
            | '(' symbol_name ')' { $$ = $2; }

          ;

/* TODO: Take care of incomplete type 
error messages for empty structs */
/* TODO: Handle array and ptr types here too */
type_name : INT { $$ = basic_types[INT_TYPE].t; }
          | FLOAT { $$ = basic_types[FLOAT_TYPE].t; }
          | CHAR { $$ = basic_types[CHAR_TYPE].t; }
          | VOID { $$ = basic_types[VOID_TYPE].t; }
          | compound_type { $$ = $1; }
          | ALIAS_NAME { $$ = *$1; }
          ;

opt_init  :  '=' expr   { $$ = $2; }
          | /* empty */ { $$.type.ttype = UNDEF_TYPE; }
        ;

/* TODO: array initializers, struct initializers */
primary_expr  : CONSTANT  { 
                  char *temp;
                  copy_name(&temp, $1.val.const_str);
                  $$ = create_const_expr(temp);
                  SET_NOT_DEREF($$);
                }
              | IDENTIFIER { 
                  symrec *rec = getsym(active_func, $1, scope);
                  if (!rec) {
                    error("Undefined symbol\n");
                  }
                  $$ = create_sym_expr(rec);
                  SET_NOT_DEREF($$);
                }
              | '(' expr ')' { $$ = $2; }
              | function_call { $$ = $1; }
              ;

/* function call will be a standard expr type */
function_call : func_name '(' actual_params_list ')'
                {
                  struct func_rec *func = search_func($1);
                  if (!func)
                    error("Undefined function");

                  struct list *fp = func->param_list;
                  struct list *ap = $3;

                  struct type t;
                  struct expr_type *e; int arg_num = 0;

                  while (fp && ap) {
                    arg_num++;
                    t = ((symrec *)fp->data)->type;
                    e = (struct expr_type *)ap->data;
                    if (!is_equiv(t, e->type))
                      if (is_coercible(t, e->type))
                        warning("implicit type conversion while passing parameters");
                      else
                        error("incompatible type for argument");
                    out_param(*e);
                    fp = fp->next;
                    ap = ap->next;
                  }

                  if (fp || ap)
                    error("argument number mismatch");

                  $$.ptr = QUAD_PTR; $$.val.quad_no = next_quad;
                  $$.type = func->ret_type;
                  SET_NOT_DEREF($$);
                  out_call(func);

                  /*TODO: Free every shit*/
                }
              ;

func_name : IDENTIFIER { copy_name(&$$, $1); }

actual_params_list  : actual_params { $$ = $1; }
                    | /* empty */ { $$ = NULL; }
actual_params : eval_expr
                {
                  struct expr_type *e = malloc(sizeof(struct expr_type));
                  *e = $1;
                  $$ = list_create_elem(e);
                }
              | eval_expr ',' actual_params
                {
                  struct expr_type *e = malloc(sizeof(struct expr_type));
                  *e = $1;
                  list_prepend_elem(&$3, list_create_elem(e));
                  $$ = $3;
                }
              ;

/* So that any delayed evaluation can be 
 * output to a temp variable */
eval_expr : expr 
            {
              if (is_indexed($1) || is_derefd($1))
                $$ = get_vector_elem($1);
              else
                $$ = $1;
            }
          ;

// Note that basic types can be inconverted , but compound types can't
// i.e struct test t; int b = (int)t; is an error
expr    : primary_expr { $$ = $1; }
        | expr indexing 
          { 
            if (is_array($1.type)) {
              $$ = parse_indexed_expr($1, $2); 
            }
            else if (is_pointer($1.type))
              $$ = parse_deref_expr($1, $2);
            else
              error("subscripted value is neither array nor pointer nor vector");
          }
        | expr '.' IDENTIFIER { $$ = parse_member_ref($1, $3); }
        | '!' expr  { parse_unary_expr(&$$, $2, '!'); }
        | '~' expr  { parse_unary_expr(&$$, $2, '~'); }
        | '-' expr %prec UMINUS  { parse_unary_expr(&$$, $2, '-'); }
        | INC_OP expr  
          { 
            struct expr_type e = create_const_expr("1");
            parse_expr(&$$, $2, e, '+');
            if ($2.ptr != SYM_PTR) {
              error("lvalue required as increment operand");
            }
            out_assign($2.val.sym->name, $$);
          }
        | DEC_OP expr
          { 
            struct expr_type e = create_const_expr("1");
            parse_expr(&$$, $2, e, '-');
            /* TODO: Think about how pointers behave here */
            if ($2.ptr != SYM_PTR) {
              error("lvalue required as increment operand");
            }
            out_assign($2.val.sym->name, $$);
          }
        | '(' type_name ')' expr
          {
            if (!is_coercible($2, $4.type))
              error("types are not coercible");
            $$.type = $2;
            $$.val.quad_no = next_quad;
            $$.ptr = QUAD_PTR;
            out_gen_quad($4);
          }
        | '*' expr %prec DEREF
          {
            if (is_array($2.type))
              $$ = parse_indexed_expr($2, create_const_expr2(0));
            else if (is_pointer($2.type))
              $$ = parse_deref_expr($2, create_const_expr2(0));
            else
              error("Attempting to dereference non-pointer");
          }
        | expr '*' expr  { parse_expr(&$$, $1, $3, '*'); }
        | expr '/' expr  { parse_expr(&$$, $1, $3, '/'); }
        | expr '%' expr  { parse_expr(&$$, $1, $3, '%'); }
        | expr '+' expr  { parse_expr(&$$, $1, $3, '+'); }
        | expr '-' expr  { parse_expr(&$$, $1, $3, '-'); }
        | expr LSHFT_OP expr  { parse_expr(&$$, $1, $3, LSHFT_OP); }
        | expr RSHFT_OP expr  { parse_expr(&$$, $1, $3, RSHFT_OP); }
        | expr '>' expr  { parse_expr(&$$, $1, $3, '>'); }
        | expr '<' expr  { parse_expr(&$$, $1, $3, '<'); }
        | expr LE_OP expr  { parse_expr(&$$, $1, $3, LE_OP); }
        | expr GE_OP expr  { parse_expr(&$$, $1, $3, GE_OP); }
        | expr EQ_OP expr  { parse_expr(&$$, $1, $3, EQ_OP); }
        | expr NE_OP expr  { parse_expr(&$$, $1, $3, NE_OP); }        
        | expr '|' expr  { parse_expr(&$$, $1, $3, '|'); }
        | expr '^' expr  { parse_expr(&$$, $1, $3, '^'); }
        | expr '&' expr  { parse_expr(&$$, $1, $3, '&'); }
        | expr AND_OP expr  { parse_expr(&$$, $1, $3, AND_OP); }
        | expr OR_OP expr  { parse_expr(&$$, $1, $3,  OR_OP); }
        // Need to change primary_expr to general expression
        | expr '=' expr  { parse_assignment($1, $3); $$ = $1; }
        ;

indexing  : '[' expr ']'
            {
              if (is_indexed($2) || is_derefd($2))
                $$ = get_vector_elem($2);
              else
                $$ = $2;
              if (!is_int_expr($$)) // or convertible to int
                error("array subscript is not an integer");
            }
          ;
/* End of grammar */
%%

struct bigop bigops[] = {
    {OR_OP, "||"},
    {AND_OP, "&&"},
    {EQ_OP, "=="},
    {NE_OP, "!="},
    {LE_OP, "<="},
    {GE_OP, ">="},
    {LSHFT_OP, "<<"},
    {RSHFT_OP, ">>"},
    {INC_OP, "++"},
    {DEC_OP, "--"}
};

int
main (int argc, char **argv)
{
  const char *filename = "";

  if (argc > 1)
    filename = argv[1];
  /* TODO: Parse args properly */
  outfile = fopen(DEFAULT_OUT, "w+");
  if (!outfile) {
    printf("Error opening output file\n");
    exit(1);
  }

  init_globals(filename);
  init_tables();

  yyparse ();
}

void
init_globals(char *infile) {
  int i;
  BIGOPS_NUM = sizeof(bigops);
  // Current loop information
  cur_loop.patch = cur_loop.label = -1;
  // temporary number
  next_quad = 0;
  // label and patch system
  label_no = 1; patch_idx = 0;
  nested = NULL;
  for (i = 0; i< MAX_NEST_DEPTH; ++i)
    patches[i] = 0;
  scope.level = scope.label = scope.over = 0;
  active_func = NULL;
  if (infile)
    yyin = fopen(infile, "r");
  else
    yyin = stdin;

}

yyerror (s)  /* Called by yyparse on error */
     char *s;
{
  printf ("%s\n", s);
}

void
error (char *msg) {
  printf("\n%d:%d: error: %s\n", lineno, colno, msg);
  fclose(outfile);
  fclose(yyin);
  exit(1);
}

void
warning (char *msg) {
  printf("\n%d:%d: warning: %s\n", lineno, colno, msg);
}

struct init
{
  char *fname;
  double (*fnct)();
};


void
out_assign(char *name, struct expr_type expr) {
  char *s = NULL;
  assign_name_to_buf(&s, expr);

  fprintf(outfile, "\t %s = %s\n", name, s);

  free(s);
  return;
}


void 
out_gen_quad (struct expr_type e) {
  char *temp = malloc(10 * sizeof(int));
  temp_var_name(next_quad++, temp);
  out_assign(temp, e);

  free(temp);
  return;
}

int
out_jmp(struct expr_type *e, void *label, int type) {
  char *ltext, *cond, *name = NULL; int i = -1;
  int mf1 = 0;
  if (!label) {
    // 5 spaces, temporarily so that label name can be accomodated
    mf1 = 1;
    i = 0;
    while(i < MAX_NEST_DEPTH && i < patches[i])
      i++;
    if (i == MAX_NEST_DEPTH)
      error("Can't nest more than 256 levels");

    make_patch_text(&ltext, i);
    patches[i] = 1;
  }
  else {
    if (type == JUMP_LABEL_NUMBER) {
      mf1 = 1;
      make_label_text(&ltext, *((int *)label));
    }
    else if (type == JUMP_LABEL_NAME)
      ltext = (char *)label;
    else {
      // Jump to patch number
      mf1 = 1;
      make_patch_text(&ltext, *((int *) label));
    }
  }

  if (e) {
    cond = malloc(100 * sizeof(char));
    assign_name_to_buf(&name, *e);
    snprintf(cond, 100, "if ( %s == 0 )", name);
  }
  else 
    cond = "";

  fprintf(outfile, "\t %s\n\t goto %s\n", cond, ltext);

  if (mf1) free(ltext);
  if (e) {
    free(cond);
    free(name);
  }


  return i;
}

void backpatch(int label, int patch) {
  int tp; int write_pos; int temp_pos;
  int cur_pos = ftell(outfile); 
  char c;
  char *ltext; 

  make_label_text(&ltext, label);
  fseek(outfile, 0, SEEK_SET);
  while ((c = getc(outfile)) != EOF) {
    if (c != '$')
      continue;
    write_pos = ftell(outfile) - 1;
    fscanf(outfile, "%d", &tp);
    temp_pos = ftell(outfile);
    if (tp == patch) {
      fseek(outfile, write_pos, SEEK_SET);
      fprintf(outfile, "%s", ltext);
    }
    fseek(outfile, temp_pos, SEEK_SET);
  } 


  fseek(outfile, cur_pos, SEEK_SET);
  patches[patch] = 0;
  free(ltext);
}


void
parse_unary_expr (struct expr_type *result, 
              struct expr_type e1, int op) {
    if (is_indexed(e1) || is_derefd(e1))
      e1 = get_vector_elem(e1);
    // Check for coercibility here
    int qno = next_quad;
    make_two_quad(e1, op);

    result->ptr = QUAD_PTR; 
    result->val.quad_no = qno;
    result->type = e1.type;
    SET_NOT_DEREF((*result));
    // $$.type = MAX($1.type, $3.type);
}

void
parse_vector_expr (struct expr_type *result, struct expr_type e1,
          struct expr_type e2, int op) {
  int sub_flag = 0; int qno;
  if (is_relational(op) || is_logical(op))
      goto vec_fin;
  /* Atleast one of the two is a pointer, so 
   * if this condition is true, both of them are */
  if (op == '-' && is_equiv(e1.type, e2.type)) {
    sub_flag = 1;
    goto vec_fin;
  }
  if (is_plus(op)) {
    if (is_int_type(e1.type)) {
      parse_expr(&e1, e1, 
        create_const_expr2(size_of_target(e2.type)), '*'); 
      goto vec_fin;
    }
    else if (is_int_type(e2.type)) {
      parse_expr(&e2, e2,
        create_const_expr2(size_of_target(e1.type)), '*'); 
      goto vec_fin;
    }
  }
  error("Invalid operands type to binary operator");

  vec_fin:
  qno = next_quad;
  make_quad(e1, e2, op);
  result->ptr = QUAD_PTR; result->val.quad_no = qno;
  result->type = basic_types[INT_TYPE].t;
  SET_NOT_DEREF((*result));

  if (sub_flag) {
    parse_expr(result, *result, 
      create_const_expr2(size_of_target(e1.type)), '/');
  }
}

void
parse_expr (struct expr_type *result, struct expr_type e1,
          struct expr_type e2, int op) {
  int qno;
  /* TODO: Check for coercibility here */
  if (is_indexed(e1) || is_derefd(e1)) {
    e1 = get_vector_elem(e1);
  }
  if (is_indexed(e2) || is_derefd(e2)) {
    e2 = get_vector_elem(e2);
  }
  if (is_compound(e1.type) || is_compound(e2.type))
    error("Invalid struct argument type to binary operator, expected scalar");
  /* array and pointer operations */
  if (is_vector(e1.type) || is_vector(e2.type)) {
    parse_vector_expr(result, e1, e2, op);
    return;
  }

  output:
  qno = next_quad;
  make_quad(e1, e2, op);
  result->ptr = QUAD_PTR; result->val.quad_no = qno;
  result->type = e1.type;
  SET_NOT_DEREF((*result));
}

void
make_two_quad (struct expr_type e1, int op) {
    // Store line number in quad table if needed
    char tname[10]; temp_var_name(next_quad, tname);    
        
    char *s1 = NULL;
    assign_name_to_buf(&s1, e1);

    fprintf(outfile, "\t %s = %c %s \n", tname, (char)op, s1);
    next_quad++;

    free(s1);
    return;
}

void
make_quad_by_name (char *e1, char *e2, int op) {
  char tname[10]; temp_var_name(next_quad++, tname);
  int i, idx = -1;
  for (i = 0; i < BIGOPS_NUM; ++i) {
    if (bigops[i].op == op)
      idx = i;
  }
  if (idx == -1) {

    fprintf(outfile, "\t %s = %s %c %s\n", tname, e1, (char)op, e2);
  }
  else {

    fprintf(outfile, "\t %s = %s %s %s\n", tname, e1, bigops[idx].str, e2);
  }
  return;
}

void
make_quad_with_const (struct expr_type e, char *const_str, int op) {
  char *name = NULL; int mf;
  assign_name_to_buf(&name, e);
  make_quad_by_name(name, const_str, op);

  free(name);
}

void
make_quad (struct expr_type e1, struct expr_type e2, int op) {        
  char *s1 = NULL, *s2 = NULL;
  assign_name_to_buf(&s1, e1);
  assign_name_to_buf(&s2, e2);   
  make_quad_by_name(s1, s2, op);
  free(s1); free(s2);
  return;
}

/* TODO: Change */
struct expr_type
parse_member_ref (struct expr_type e, char *mem) {
  struct expr_type ret = e;
  if (!is_compound(e.type))
    error("request for member in something not a structure or union");

  int oft = struct_calc_offset(e.type.val.stype, mem);
  if (oft == -1)
    error("struct has no member named this");
  ret.type = struct_get_elem(e.type.val.stype, oft);

  if (is_indexed(e)) {
    /* Case of a.b.c */
    if (is_mem_ref(e))
      ret.deref.mem_oft += oft;
    /* Case of a[5].e */
    else {
      char *const_str = citostr(oft);
      *(ret.deref.idx) = create_temp_expr(next_quad, 
                          basic_types[INT_TYPE].t);
      make_quad_with_const(*(e.deref.idx), const_str, '+');
    }
  }
  else {
    if (!is_derefd(e)) {
      /* Get address if not a pointer */
      int temp = next_quad;
      out_addr_of(e);
      ret = create_temp_expr(temp, ret.type);
    }
    SET_NOT_DEREF(ret);
    ret.deref.type = INDEX_EXPR;
    ret.deref.mem_oft = oft;
  }
  return ret;
}

/* Multiplies the offset of a vector by the size of
 * target. Thus, for out_vector_offset(*t, 2),
 * we would get _t0 = 2 * sizeof(*t) and so on */
void
out_vector_offset (struct expr_type e, struct expr_type idx) {
  char *const_str = citostr(size_of_target(e.type));
  make_quad_with_const(idx, const_str, '*');
  free(const_str);
  return;
}

void
out_index (struct expr_type e) {
  int oft_temp = next_quad, mf;
  char *name = NULL;
  out_vector_offset(e, *e.deref.idx);
  // error("Here");

  char tname[10], oft_name[10]; 
  assign_name_to_buf(&name, e);
  symrec *sym = getsym(active_func, name, scope);

  temp_var_name(next_quad++, tname);
  temp_var_name(oft_temp, oft_name);
  fprintf(outfile, "\t if ( %s < %d ) goto _L%d\n", oft_name, 
    sym->type.array.size * base_size_of(sym->type), label_no);
  fprintf(outfile, "\t exit 1\n");
  out_label();
  fprintf(outfile, "\t %s = %s [%s]\n", tname, name, oft_name);

  free(name);
}

void
out_const_index (struct expr_type e, const int c) {
  /* TODO: Take care of sizes (10 here) by allocating
   * global buffers maybe */
  char *name = NULL;
  assign_name_to_buf(&name, e);
  struct type *t = &e.type;
  fprintf(outfile, "\t _t%d = %s[%d]\n", next_quad++, name, c);
  free(name);
  return;
}

/* Called only for pointer dereferencing */
void
out_deref (struct expr_type e) {
  char *temp, *name = NULL;
  assign_name_to_buf(&name, e);
  temp = malloc(10 * sizeof(char));
  temp_var_name(next_quad++, temp);

  fprintf(outfile, "\t %s = * %s\n", temp, name);

  free(temp);  free(name);
}

/* Generated just above, for exmaple: int *p;
 * a = p[5] becomes _t0 = 5 * sizeof(*p);
 * _t1 = p + _t0; a = *_t1; */
void
out_deref_by_index (struct expr_type e) {
  struct expr_type final_ptr; 
  /* Get offset in bytes _t0 = 5 * sizeof(*p) */
  int oft_temp = next_quad;
  out_vector_offset(e, *e.deref.idx);

  /* Add offset to base address _t1 = p + _t0 */
  char oft[10]; char *base = NULL; 
  int final_addr = next_quad;
  assign_name_to_buf(&base, e);
  temp_var_name(oft_temp, oft);
  make_quad_by_name(base, oft, '+');

  /* Dereference the final address */
  final_ptr.type = e.type; 
  final_ptr.ptr = QUAD_PTR;
  final_ptr.val.quad_no = next_quad;
  final_ptr.deref = e.deref;

  out_deref(final_ptr);

  free(base);
}

void
out_addr_of (struct expr_type e) {
  char *name = NULL;
  assign_name_to_buf(&name, e);
  fprintf(outfile, "_t%d = &%s\n", next_quad++, name);
  free(name);
}

/* e.deref contains the details of the dereference */
struct expr_type
get_vector_elem (struct expr_type e) {
  struct expr_type ret;
  SET_NOT_DEREF(ret);
  ret.ptr = QUAD_PTR;
  ret.val.quad_no = next_quad;
  ret.type = e.type;
  if (is_derefd(e)) {
    out_deref(e);
  } 
  else if (is_mem_ref(e)) {
    /* Struct member ref */
    out_const_index(e, e.deref.mem_oft);
  }
  else {
    /* Array indexing */
    out_index(e);
    ret.val.quad_no++;
  }
  free(e.deref.idx);
  return ret;
}

void out_label () {
  char *ltext; 
  make_label_text(&ltext, label_no++);
  fprintf(outfile, "%s: \n", ltext);
  free(ltext);
}

/* Compound index in case of accesses like
 * a[2][3], and a.x[2] */
struct expr_type
cmpnd_idx (struct expr_type e, struct expr_type idx) {
  struct expr_type ret = e;
  int t = next_quad;
  out_vector_offset(e, idx);

  /* Add the old index to the new idx */
  char temp[20]; temp_var_name(t, temp);
  int final_quad = next_quad;
  make_quad_with_const(*(e.deref.idx), temp, '+');

  ret.type = arr_reduce_dimen(e.type);
  ret.deref.idx = malloc(sizeof(struct expr_type));
  /* Make new int idx */
  *(ret.deref.idx) = create_temp_expr(final_quad, basic_types[INT_TYPE].t);
  return ret;
}

/* Change const offset to idx expr */
struct expr_type
cmpnd_idx2 (struct expr_type e, struct expr_type idx) {
  e.deref.idx = malloc(sizeof(struct expr_type));
  *(e.deref.idx) = create_const_expr(citostr(e.deref.mem_oft));
  e.deref.mem_oft = -1;
  return cmpnd_idx(e, idx);
}

/* Carry forward the indexing information in e.deref
 * Only array indexing things are passed here, 
 * pointer indexes go to parse_deref_expr */
struct expr_type
parse_indexed_expr (struct expr_type e, struct expr_type idx) {
  struct expr_type ret;
  out_assign_expr(create_temp_expr(next_quad, idx.type), idx);
  fprintf(outfile, "if (_t%d < %d) goto _L%d\n\texit\n", next_quad++, 
          e.type.array.size, label_no);
  out_label();

  if (is_indexed(e)) {
    if (is_mem_ref(e)) {
      return cmpnd_idx2(e, idx);
    }
    else {
      return cmpnd_idx(e, idx);
    }
  }
  /* This will be only encountered in case of 
   * defs like int (*a)[5]; otherwise they'll go to
   * parse_pointer_deref */
  if (is_derefd(e))
    e = get_vector_elem(e);

  /* Indexed for a simple array */
  ret = e;
  ret.type = arr_reduce_dimen(e.type);
  ret.deref.type = INDEX_EXPR;
  ret.deref.idx = malloc(sizeof(struct expr_type));
  *(ret.deref.idx) = idx;
  return ret;
}


/* For expressions of the type *(p + 5), this outputs
 * _t0 = p + 5 */
struct expr_type
parse_deref_expr (struct expr_type e, struct expr_type idx) {
  // Create a temp expression of the same type
  struct expr_type plus = create_temp_expr(next_quad, basic_types[INT_TYPE].t);
  // Output _t0 = p + 5
  out_vector_offset(e, idx);
  struct expr_type ne = create_temp_expr(next_quad, e.type);
  make_quad(e, plus, '+');
  ne.deref.type = DEREF_EXPR;
  return ne;
}

int 
sout_expr_with_deref (char *buf, struct expr_type e) {
  int t1 = next_quad; char *name = NULL;
  assign_name_to_buf(&name, e);
  if (is_derefd(e)) {
    // exit(1);
    return sprintf(buf, "*%s ", name);
  }
  else if (is_indexed(e)) {
    if (is_mem_ref(e)) {
      return sprintf(buf, "\t %s[%d]", name, e.deref.mem_oft);
    }
    else {
      out_vector_offset(e, *(e.deref.idx));
      // fprintf(outfile, "\t if ( _t%d < %d ) goto _L%d\n", t1, 
      //     sym->type.array.size * base_size_of(sym->type), label_no);
      // fprintf(outfile, "\t exit 1\n");
      out_label();
      return sprintf(buf, "\t %s[_t%d] ", name, t1);
    }
  }
  else {
    return sprintf(buf, "\t %s", name);
  }
}

void
out_assign_expr (struct expr_type lval, struct expr_type rval) {
  char *assign = malloc(2 * MAX_IDENTIFIER_SIZE * sizeof(char));
  int pos = 0;
  /* Print lvalue */
  pos += sout_expr_with_deref(assign, lval);
  assign[pos++] = ' ';  assign[pos++] = '='; assign[pos++] = ' ';
  /* print rvalue */
  pos += sout_expr_with_deref(assign + pos, rval);

  fprintf(outfile, "\t %s\n", assign);

  free(assign);
  return;
}
void
parse_assignment (struct expr_type lval, struct expr_type rval) {
  struct expr_type result; 
  struct type lt = lval.type, rt = rval.type;
  if (is_void_type(rt))
    error("void value not ignored as it ought to be");
  if (!is_assignable(lval))
    error("error: lvalue required as left operand of assignment");
  if (is_equiv(lt, rt)) {
    out_assign_expr(lval, rval);
    return;
  }
  if (is_coercible(lt, rt)) {
    warning("implicit conversion between types");
    out_assign_expr(lval, rval);
    return;
  } 
  /* Inconvertible, eg. incompatible types when assigning
   * to type 'float' from type 'int *' */
  error("Incompatible types for assignment");
}

void
out_begin_func () {
  fprintf(outfile, "FUNCTION %s() BEGIN:\n", active_func->name);
}

void
out_end_func () {
  fprintf(outfile, "FUNCTION END\n\n\n");
}

void
out_return (struct expr_type *e) {
  if (!e) {
    if (!is_void_type(active_func->ret_type))
      warning("'return' with no value, in function returning non-void");
    fprintf(outfile, "\t return\n");
    return;
  }
  if (is_void_type(active_func->ret_type)) 
    warning("'return' with a value, in function returning void");
  else if (!is_equiv(e->type, active_func->ret_type)) {
    if (!is_coercible(e->type, active_func->ret_type))
      error("incompatible types when returning type");
  }

  char *name = NULL; assign_name_to_buf(&name, *e);
  fprintf(outfile, "\t return %s\n", name);

  free(name);
}


void
out_param (struct expr_type e) {
  char *name = NULL;
  assign_name_to_buf(&name, e);

  fprintf(outfile, "\t param %s\n", name);
  free(name);
}

void
out_call (struct func_rec *f) {
  if (!is_void_type(f->ret_type))
    fprintf(outfile, "\t param _result\n");
  fprintf(outfile, "\t call %s, %d\n", f->name, f->num_param);
  if (!is_void_type(f->ret_type))
    fprintf(outfile, "\t _t%d = _result\n", next_quad++);

  return;
}


=========================  lex.l



D			[0-9]
L			[a-zA-Z_]
H			[a-fA-F0-9]
E			[Ee][+-]?{D}+
FS			(f|F|l|L)
IS			(u|U|l|L)*

%{
#include <stdio.h>
#include "calc.h"
#include "utils.h"
#include "func.h"
#include "y.tab.h"
#include "gramm.h"
#include <stdlib.h>
#include <string.h>

char id_name[200];

int check_type();

void count();
%}

%option yylineno

%%
"/*"			{ comment(); }
"//"			{ line_comment(); }

"auto"			{ count(); return(AUTO); }
"break"			{ count(); return(BREAK); }
"case"			{ count(); return(CASE); }
"char"			{ count(); return(CHAR); }
"const"			{ count(); return(CONST); }
"continue"		{ count(); return(CONTINUE); }
"default"		{ count(); return(DEFAULT); }
"do"			{ count(); return(DO); }
"double"		{ count(); return(DOUBLE); }
"else"			{ count(); return(ELSE); }
"enum"			{ count(); return(ENUM); }
"extern"		{ count(); return(EXTERN); }
"float"			{ count(); return(FLOAT); }
"for"			{ count(); return(FOR); }
"goto"			{ count(); return(GOTO); }
"if"			{ count(); return(IF); }
"int"			{ count(); return(INT); }
"long"			{ count(); return(LONG); }
"register"		{ count(); return(REGISTER); }
"return"		{ count(); return(RETURN); }
"short"			{ count(); return(SHORT); }
"signed"		{ count(); return(SIGNED); }
"sizeof"		{ count(); return(SIZEOF); }
"static"		{ count(); return(STATIC); }
"struct"		{ count(); return(STRUCT); }
"switch"		{ count(); return(SWITCH); }
"typedef"		{ count(); return(TYPEDEF); }
"union"			{ count(); return(UNION); }
"unsigned"		{ count(); return(UNSIGNED); }
"void"			{ count(); return(VOID); }
"volatile"		{ count(); return(VOLATILE); }
"while"			{ count(); return(WHILE); }

{L}({L}|{D})*		{ 
					  count();
					  return(check_type());
					}

0[xX]{H}+{IS}?		{ count();  yylval.e.val.const_str = yytext; return(CONSTANT);}
0{D}+{IS}?		{ count();  yylval.e.val.const_str = yytext; return(CONSTANT);}
{D}+{IS}?		{ count();  yylval.e.val.const_str = yytext; return(CONSTANT);}
L?'(\\.|[^\\'])+'	{ count();  yylval.e.val.const_str = yytext; return(CONSTANT);} 

{D}+{E}{FS}?		{ count();  yylval.e.val.const_str = yytext; return(CONSTANT);}
{D}*"."{D}+({E})?{FS}?	{ count();  yylval.e.val.const_str = yytext; return(CONSTANT);}
{D}+"."{D}*({E})?{FS}?	{ count();  yylval.e.val.const_str = yytext; return(CONSTANT);}

"&&"		{ return (AND_OP);}
"||"		{ return (OR_OP);}
"<="		{ return (LE_OP);}
">="		{ return (GE_OP);}
"=="		{ return (EQ_OP);}
"!="		{ return (NE_OP);}
"<<"		{ return (LSHFT_OP);}
">>"		{ return (RSHFT_OP);}
"++"		{ return (INC_OP);}
"--"		{ return (DEC_OP);}

";"			{ count(); return(';'); }
("{"|"<%")		{ count(); return('{'); }
("}"|"%>")		{ count(); return('}'); }
","			{ count(); return(','); }
":"			{ count(); return(':'); }
"="			{ count(); return('='); }
"("			{ count(); return('('); }
")"			{ count(); return(')'); }
("["|"<:")		{ count(); return('['); }
("]"|":>")		{ count(); return(']'); }
"."			{ count(); return('.'); }
"&"			{ count(); return('&'); }
"!"			{ count(); return('!'); }
"~"			{ count(); return('~'); }
"-"			{ count(); return('-'); }
"+"			{ count(); return('+'); }
"*"			{ count(); return('*'); }
"/"			{ count(); return('/'); }
"%"			{ count(); return('%'); }
"<"			{ count(); return('<'); }
">"			{ count(); return('>'); }
"^"			{ count(); return('^'); }
"|"			{ count(); return('|'); }
"?"			{ count(); return('?'); }

[ \t\v\n\f]		{ count(); }
.			{ /* ignore bad characters */ }

%%

yywrap()
{
	return(1);
}


comment()
{
	char c, c1;

loop:
	while ((c = input()) != '*' && c != 0)
		putchar(c);

	if ((c1 = input()) != '/' && c != 0)
	{
		unput(c1);
		goto loop;
	}

	if (c != 0)
		putchar(c1);
}

line_comment () 
{
	char c;
	while ((c = input()) != '\n' && c)
		putchar(c);
	return;
}

int column = 0;

void count()
{
	int i;

	for (i = 0; yytext[i] != '\0'; i++)
		if (yytext[i] == '\n')
			column = 0;
		else if (yytext[i] == '\t')
			column += 8 - (column % 8);
		else
			column++;
	lineno = yylineno;
	colno = column;
	ECHO;
}


int check_type()
{
	struct type *alias_type;
	if (alias_type = get_alias(yytext)) {
		yylval.alias_type = alias_type;
		return (ALIAS_NAME);
	}

	int len = strlen(yytext);
	// printf("yytext: %s\n", yytext);
	strcpy(id_name, yytext);
	yylval.id_name = id_name;

	return(IDENTIFIER);
}




=========================  utils.c


#include "utils.h"
#include "func.h"
#include "gramm.h"
#include <stdlib.h>
#include <string.h>
#include <stdio.h>

typedef struct {
  int type;
  union {
    int i; float f;
  } val;
} b10_val;

/* Takes only positive const strings and returns a value */
b10_val hex_val (char *str) {
  int ipart = 0; int type = INT_TYPE;
  b10_val ret; ret.type = UNDEF_TYPE;
  int last; float fpart = 0;
  if (!str)
    return ret;
  if (!(str[0] == '0' && str[1] == 'x'))
    return ret;

  int i; 
  for (i = 0; str[i] && str[i] != '.'; i++) {
    ipart = (ipart * 16) + (str[i] - '0');
  }

  if (str[i] == '.') {
    last = strlen(str) - 1;
    type = FLOAT_TYPE;
    for (i = last; str[i] != '.'; --i)
      fpart = (fpart + (str[i] - '0') ) / 16;
  }
  ret.type = type;
  if (type == FLOAT_TYPE)
    ret.val.f = ipart + fpart;
  else
    ret.val.i = ipart;

  return ret;
}

/* TODO: Also add pointer deref. here */
struct type
arr_reduce_dimen (struct type t) {
  struct type ret;
  if (!is_array(t)) {
    ret.ttype = UNDEF_TYPE;
    return ret;
  }
  ret = t;
  // Arrays are copied by value here.
  ret.array.dimen = malloc((t.array.n - 1) * sizeof(int));
  ret.array.size /= t.array.dimen[0];

  int i;
  for (i = 1; i < t.array.n; ++i)
    ret.array.dimen[i - 1] = t.array.dimen[i];
  ret.array.n = t.array.n - 1;
  return ret;
}

struct type
pointer_deref (struct type t) {
  struct type ret;
  ret.ttype = UNDEF_TYPE;
  if (is_array(t))
    return arr_reduce_dimen(t);
  else if (!is_pointer(t))
    return ret;

  return *(t.val.ptr_to);
}

struct expr_type 
create_const_expr (char *const_str) {
  struct expr_type e; e.type.ttype = UNDEF_TYPE;
  if (!const_str)
    return e;
  e.type.ttype = BASIC_TYPE;
  e.type.val.btype = const_type(const_str);
  SET_NOT_ARRAY(e.type);
  e.ptr = CONST_PTR;
  e.val.const_str = const_str;
  SET_NOT_DEREF(e);
  return e;
}

struct expr_type 
create_const_expr2 (const int c) {
  struct expr_type e; e.type.ttype = UNDEF_TYPE;
  int size = digits(c) + 1;
  char *const_str = malloc(size * sizeof(char));
  snprintf(const_str, size, "%d", c);
  
  e.type = basic_types[INT_TYPE].t;

  e.ptr = CONST_PTR;
  e.val.const_str = const_str;
  SET_NOT_DEREF(e);
  return e;
}

struct expr_type
create_temp_expr (int temp, struct type t) {
  struct expr_type e;
  e.ptr = QUAD_PTR;
  e.val.quad_no = temp;
  e.type = t;
  SET_NOT_DEREF(e);

  return e;
}

struct expr_type
create_sym_expr (symrec *sym) {
  struct expr_type ret; 
  ret.type.ttype = UNDEF_TYPE;
  if (!sym)
    return ret;
  SET_NOT_ARRAY(ret.type);
  ret.ptr = SYM_PTR; 
  ret.type = sym->type;  // Think about it: redundancy, how to eliminate
  ret.val.sym = sym;
  SET_NOT_DEREF(ret);
  return ret; 
}

int
const_type (char *const_str) {
  /* TODO: Maybe set the type
  * from the lexer itself */
  if (const_str[0] == '\'' && const_str[2] == '\'' && !const_str[3])
    return CHAR_TYPE;
  int i = 0;
  while (const_str[i]) {
    if (const_str[i] == '.')
      return FLOAT_TYPE;
    i++;
  }
  return INT_TYPE;
}

int 
const_val (char *const_str) {
  if (const_type(const_str) == CHAR_TYPE)
    return const_str[1];
  // Add hex and octal support
  // Also stirng literals
  return atoi(const_str);
}

int
is_coercible (struct type to, struct type from) {
  if (to.ttype == COMPOUND_TYPE || from.ttype == COMPOUND_TYPE)
      return 0;
  if (is_int_type(to) || is_int_type(from)) {
    if (size_of(to) != size_of(from))
      // With warning
      return 2;
    return 1;
  }
  if (is_vector(to) && is_vector(from))
      return 1;
  return (is_equiv(to, from));
}

int
is_lval_type (struct type t) {
  if (is_array(t))
    return 0;  
  return 1;
}

void
array_decay (struct expr_type *e) {
  if (!is_array(e->type))
    return;
  struct type *t = malloc(sizeof(struct type));
  *t = e->type;
  e->type.ttype = PTR_TYPE;
  e->type.val.ptr_to = t;
  SET_NOT_ARRAY(e->type);
  SET_NOT_ARRAY(*t);
  return;
}

/* expressions are assignable only if they are an
 * indexing or deref or a symbol */
int
is_assignable (struct expr_type e) {
  struct type t = e.type;
  /* An array or pointer dereference 
   * is a memory address, thus always
   * assignable */
  if (is_indexed(e) || is_derefd(e)) {
    return is_lval_type(t);
  }
  
  /* Is this a symbol table entry */
  if (e.ptr == SYM_PTR) {
    return is_lval_type(t);
  }
  /* Otherwise not assignable, for 
   * constants and other exprs */
  return 0;
}

void 
copy_name (char **buf, char *name) {
  if (!name)
    return;
  *buf = malloc((strlen(name)  + 1)* sizeof(char));
  strcpy(*buf, name);
  return;
}

int 
is_equiv(struct type t1, struct type t2) {
  int eq_flag = 1;
  if (is_vector(t1) != is_vector(t2))
    return 0;
  if (t1.ttype == UNDEF_TYPE || t2.ttype == UNDEF_TYPE)
    return 0;
  if (t1.ttype != t2.ttype)
    return 0;
  // Check the dimensions too
  if (t1.array.n != t2.array.n)
    return 0;
  if (t1.ttype == PTR_TYPE) {
    return is_equiv(*t1.val.ptr_to, *t2.val.ptr_to);
  }
  else if (t1.ttype == COMPOUND_TYPE) {
    return (t1.val.stype == t2.val.stype);
  }
  else return (t1.val.btype == t2.val.btype);

}

int
is_incompl_type (struct type t) {
  if (t.ttype == INCOMPL_TYPE ||
      t.ttype == UNDEF_TYPE)
    return 1;
  if (t.ttype == COMPOUND_TYPE && 
      t.val.stype->size == -1)
    return 1;
  return 0;
}


void 
list_join (struct list **l, struct list **m) {
    if (!*l) {
        *l = *m;
        return;
    }
    struct list *node = *l;
    while (node->next) 
        node = node->next;

    node->next = *m;
    return;
}

void 
list_append_elem (struct list **l, struct list *elem) {
    if (!l)
        return;

    if (!*l) {
        *l = elem;
        return;
    }
    struct list *node = *l;
    while (node->next)
        node = node->next;
    node->next = elem;
    return;
}

void 
list_prepend_elem (struct list **l, struct list *elem) {
    if (!l)
        return;
    elem->next = *l;
    *l = elem;
    return;
}

struct list *
list_create_elem (void *data) {
    struct list *newnode = malloc(sizeof(struct list));
    newnode->data = data;
    newnode->next = NULL;

    return newnode;
}

void *
list_pop_front (struct list **l) {
    if (!l || !*l)
        return NULL;
    struct list *elem = *l;
    *l = elem->next;
    void *data = elem->data;
    free(elem);
    return data;
}


void
make_label_text (char **buf, int label) {
    *buf = malloc(101 * sizeof(char));
    snprintf(*buf, 100, "_L%d", label);    
}

void 
make_patch_text (char **buf, int patch) {
    *buf = malloc(10 * sizeof(char));
    snprintf(*buf, 10, "$%d     ", patch);  
}

/* Ugly stuff, but basically if we pass a pointer to
 * a NULL ptr, then we assign a buffer, else assume the 
 * buffer is already assigned, the (int **) is cast 
 * to (int *) */
int
assign_name_to_buf(char **buf, struct expr_type e) {
  int mf = 0; int pos = 0; char *name;

  if (!*buf) {
    // printf("NOT *buf");
    *buf = malloc(MAX_IDENTIFIER_SIZE * sizeof(char));
    name = *buf;
  }
  else 
    name = (int *)buf;
  // if (is_derefd(e))
  //   name[pos++] = '*';

  if (e.ptr == CONST_PTR) {
    pos += cstrcpy(name + pos, e.val.const_str) - 1;
  }
  else if (e.ptr == QUAD_PTR) {
    mf = 1;
    temp_var_name(e.val.quad_no, name + pos);
    pos += digits(e.val.quad_no) + 1;
  }
  else {
    pos += cstrcpy(name + pos, (e.val.sym)->name) - 1;
  }

  /* if e is indexed, then this will be a[idx] */
  // if (is_indexed(e)) {
  //   name[pos++] = '[';
  //   name[pos] = 1;
  //   pos += assign_name_to_buf((int **)(name + pos), *e.array.idx);
  //   name[pos++] = ']';
  // }
  name[pos + 1] = '\0';
  return pos;
}

struct type
get_target_type (struct expr_type e) {
  if (is_indexed(e)) {
    if (is_array(e.type)) {
      return arr_reduce_dimen(e.type);
    }
    else {
      /* Structures member access */
      return struct_get_elem(e.type.val.stype, e.deref.mem_oft);
    }
  }
  else if (is_derefd(e)) {
    return *(e.type.val.ptr_to);
  } 
  else
    return e.type;
}


void
temp_var_name(int idx, char *buf) {
  if (!buf)
    return;
  buf[0] = '_'; buf[1] = 't';
  snprintf(buf + 2, 7, "%d", idx);
}

/* Actually returns d + 1 for d digits */
int 
digits (int num) {
  int d = 1;
  while (num) {
    num = num / 10;
    d++;
  } 
  return d;
}

int
cstrcpy (char *dest, char *src) {
  if (!src || !dest)
    return 0;
  int nchars = 0;
  while (*dest++ = *src++)
    nchars++;
  *dest = 0;
  return nchars + 1;
}

char *citostr (const int c) {
  int d = digits(c);
  char *str = malloc(d * sizeof(char));
  snprintf(str, d, "%d", c);
  return str;
}

// char *cftostr (const float f) {
//   int d = digits(c);
//   char *str = malloc(d * sizeof(char));
//   snprintf(str, d, "%d", c);
//   return str;
// }

void print_type(struct type t) {
  struct type *p = &t;
  while (p) {
    if (p->ttype == BASIC_TYPE)
      printf("(B_T, %d, %d) -> ", p->val.btype, is_array(*p));
    else if (p->ttype == COMPOUND_TYPE)
      printf("(C_T, %s, %d) -> ", p->val.stype->name, is_array(*p));
    else
      printf("(P_T, %d) -> ", is_array(*p));

    if (p->ttype == PTR_TYPE)
      p = p->val.ptr_to;
    else
      p = NULL;
  }
}

void fprint_type(FILE *tfile, struct type t) {
  struct type *p = &t;
  while (p) {
    if (p->ttype == BASIC_TYPE)
      fprintf(tfile, "(B_T, %d, %d) -> ", p->val.btype, is_array(*p));
    else if (p->ttype == COMPOUND_TYPE)
      fprintf(tfile, "(C_T, %s, %d) -> ", p->val.stype->name, is_array(*p));
    else
      fprintf(tfile, "(P_T, %d) -> ", is_array(*p));

    if (p->ttype == PTR_TYPE)
      p = p->val.ptr_to;
    else
      p = NULL;
  }
}


void dump_tables() {
  dump_sym_tables();
  // dump_struct_table();
  // dump_alias_table();
}

void dump_sym_tables() {
  const char *DUMP_FILE = "sym_tables.txt";
  printf("DUMPING all funcitons\n");
  FILE *tfile = fopen(DUMP_FILE, "w");
  if (!tfile) {
    printf("Unable to open file %s", DUMP_FILE);
    return;
  }
  struct list *node;
  for (node = func_table; node; node = node->next) {
    struct func_rec *func = (struct func_rec *)node->data;
    printf("DUMPING@@@@\n");
    fprintf(tfile, "================ FUNCTION: %s, LABEL:%d, RET_TYPE: ", func->name, func->label);
    fprint_type(tfile, func->ret_type);
    fprintf(tfile, "\n" );
    dump_table (tfile, func->sym_table);
    fprintf(tfile, "\n\n");
  }
}


void dump_table (FILE *tfile, struct list *sym_table) {
  symrec *sym;
  struct list *node; 
  for (node = sym_table; node; node = node->next) {
    sym = (symrec *)node->data;
    fprintf(tfile, "%s, %d, %d:, ", sym->name, sym->scope.level, sym->scope.label);
    fprint_type(tfile, sym->type);
    fprintf(tfile, "\n");
  }
}


=========================  utils.h


#ifndef _CALC
#include "calc.h"
#endif

#define _UTILS
#include <stdio.h>

// NEVER make a list with automatic 
// node variables, always malloc
struct list {
  void *data;
  struct list* next;
};

int is_incompl_type (struct type t);
void list_join (struct list **l, struct list **m);
void list_append_elem (struct list **l, struct list *elem);
void list_prepend_elem (struct list **l, struct list *elem);
struct list *list_create_elem (void *data);
void *list_pop_front (struct list **l) ;

void copy_name (char **, char *);

struct expr_type create_const_expr(char *const_str);
struct expr_type create_const_expr2(int c);
void array_decay (struct expr_type *e);

int is_coercible (struct type to, struct type from);

struct type pointer_deref (struct type t);
struct type arr_reduce_dimen (struct type t);

int is_assignable (struct expr_type e);
int is_equiv(struct type t1, struct type t2);

struct expr_type create_sym_expr (symrec *sym);
int const_type (char *const_str);
int const_val (char *const_str);

void make_label_text (char **buf, int label);
void make_patch_text (char **buf, int patch);

int assign_name_to_buf(char **buf, struct expr_type e);
void temp_var_name(int idx, char *buf);

int digits (int num);
int cstrcpy (char *dest, char *src);

void print_type(struct type t);

void dump_tables();
void dump_sym_tables();
void dump_table (FILE *tfile, struct list *sym_table);
void dump_struct_table ();

struct type get_target_type (struct expr_type e);
char *citostr (const int c);

struct expr_type create_temp_expr (int temp, struct type t);


